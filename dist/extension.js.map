{"version":3,"sources":["webpack://appa/./src/commandManager.ts","webpack://appa/./src/commands/formatCommands.ts","webpack://appa/./src/commands/index.ts","webpack://appa/./src/context.ts","webpack://appa/./src/logger.ts","webpack://appa/external \"path\"","webpack://appa/external \"vscode\"","webpack://appa/webpack/bootstrap","webpack://appa/./src/extension.ts"],"names":["commands","Map","registration","this","values","dispose","clear","command","registerCommand","id","execute","impl","thisArg","has","set","vscode","includeFileExtensions","includeFileNames","excludeFileNames","excludeFolders","formatAll","uri","stat","workspace","fs","basename","path","fsPath","extname","name","type","FileType","Directory","includes","dirEntries","readDirectory","dirEntry","entryName","fullEntryPath","Uri","joinPath","File","window","showTextDocument","executeCommand","e","getLogger","log","withProgress","title","location","ProgressLocation","Notification","config","getConfiguration","get","folders","workspaceFolders","folder","ctx","context","Logger","channel","createOutputChannel","message","appendLine","toString","logger","module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call","console","showInformationMessage","setContext","subscriptions","push","commandManager","CommandManager","register","FormatAllCommand","registerCommands"],"mappings":"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","file":"extension.js","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License.\r\n *  See https://github.com/microsoft/vscode/blob/master/LICENSE.txt for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\nimport * as vscode from 'vscode';\r\n\r\nexport interface Command {\r\n    readonly id: string;\r\n\r\n    execute(...args: any[]): void;\r\n}\r\n\r\nexport class CommandManager {\r\n    private readonly commands = new Map<string, vscode.Disposable>();\r\n\r\n    public dispose(): void {\r\n        for (const registration of this.commands.values()) {\r\n            registration.dispose();\r\n        }\r\n        this.commands.clear();\r\n    }\r\n\r\n    public register(...commands: Command[]): void {\r\n        for (const command of commands) {\r\n            this.registerCommand(command.id, command.execute, command);\r\n        }\r\n    }\r\n\r\n    private registerCommand(id: string, impl: (...args: any[]) => void, thisArg?: any) {\r\n        if (this.commands.has(id)) {\r\n            return;\r\n        }\r\n\r\n        this.commands.set(id, vscode.commands.registerCommand(id, impl, thisArg));\r\n    }\r\n}\r\n","import * as vscode from 'vscode';\r\n\r\nimport { Command } from '../commandManager';\r\nimport { getLogger } from '../logger';\r\n\r\nimport * as path from 'path';\r\n\r\nlet includeFileExtensions: string[] = [];\r\nlet includeFileNames: string[] = [];\r\nlet excludeFileNames: string[] = [];\r\nlet excludeFolders: string[] = [];\r\n\r\nexport class FormatAllCommand implements Command {\r\n    public readonly id = 'appa.format.formatAll';\r\n\r\n    public async execute(): Promise<void> {\r\n\r\n        vscode.window.withProgress(\r\n            {\r\n                title: \"Formatting all eligible files in workspace...\",\r\n                location: vscode.ProgressLocation.Notification,\r\n            },\r\n            async () => {\r\n                const config = vscode.workspace.getConfiguration('appa');\r\n                includeFileExtensions = config.get('includeFileExtensions', []);\r\n                includeFileNames = config.get('includeFileNames', []);\r\n                excludeFileNames = config.get('excludeFileNames', []);\r\n                excludeFolders = config.get('excludeFolders', []);\r\n\r\n                const folders = vscode.workspace.workspaceFolders;\r\n                if (!folders) {\r\n                    return;\r\n                }\r\n                for (const folder of folders) {\r\n                    await formatAll(folder.uri);\r\n                }\r\n\r\n                getLogger().log(`Formatted all files.`);\r\n            },\r\n        );\r\n    }\r\n}\r\n\r\nasync function formatAll(uri: vscode.Uri): Promise<any> {\r\n    const stat: vscode.FileStat = await vscode.workspace.fs.stat(uri);\r\n    const basename = path.basename(uri.fsPath);\r\n    const extname = path.extname(uri.fsPath);\r\n    const name = basename+extname;\r\n\r\n    if ((stat.type & vscode.FileType.Directory) === vscode.FileType.Directory) {\r\n        if (excludeFolders.includes(basename)) { return; }\r\n\r\n        const dirEntries = await vscode.workspace.fs.readDirectory(uri);\r\n\r\n        for (const dirEntry of dirEntries) {\r\n            const entryName = dirEntry[0];\r\n            const fullEntryPath = vscode.Uri.joinPath(uri, entryName);\r\n            await formatAll(fullEntryPath);\r\n        }\r\n    }\r\n    else if ((stat.type & vscode.FileType.File) === vscode.FileType.File) {\r\n        if (!includeFileNames.includes(name)){\r\n            if (!includeFileExtensions.includes(extname)) { return; }\r\n            if (excludeFileNames.includes(name)) { return; }\r\n        }\r\n        \r\n        try {\r\n            await vscode.window.showTextDocument(uri);\r\n            await vscode.commands.executeCommand('editor.action.formatDocument');\r\n        } catch (e) {\r\n            getLogger().log(\"Unable to format [\" + uri.fsPath + \"]: \" + e);\r\n        }\r\n\r\n    }\r\n}","export * from './formatCommands';","import { ExtensionContext } from 'vscode';\r\n\r\nexport function setContext(ctx: ExtensionContext): void {\r\n    context = ctx;\r\n}\r\n\r\nexport let context: ExtensionContext;\r\n","import * as vscode from 'vscode';\r\n\r\nexport class Logger {\r\n    public readonly channel: vscode.OutputChannel;\r\n\r\n    constructor(name: string) {\r\n        this.channel = vscode.window.createOutputChannel(name);\r\n    }\r\n\r\n    public log(message: unknown): void {\r\n        this.channel.appendLine((message as any).toString());\r\n    }\r\n}\r\n\r\nlet logger: Logger | undefined;\r\n\r\n/**\r\n * Gets a singleton instance of a logger that writes to an OutputChannel.\r\n */\r\nexport function getLogger(): Logger {\r\n    if (!logger) {\r\n        logger = new Logger('Extension Manager');\r\n    }\r\n\r\n    return logger;\r\n}\r\n","module.exports = require(\"path\");;","module.exports = require(\"vscode\");;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// The module 'vscode' contains the VS Code extensibility API\n// Import the module and reference it with the alias vscode in your code below\nimport * as vscode from 'vscode';\n\nimport { CommandManager } from './commandManager';\nimport * as commands from './commands/index';\nimport { setContext } from './context';\n\n\nexport function activate(context: vscode.ExtensionContext): void {\n\tconst message = 'Extension \"appa\" is now active';\n\tconsole.log(message);\n\tvscode.window.showInformationMessage(message);\n\n    setContext(context);\n\n    context.subscriptions.push(registerCommands());\n}\n\nexport function deactivate() { }\n\nfunction registerCommands(): vscode.Disposable {\n    const commandManager = new CommandManager();\n\n    commandManager.register(\n        // Format commands\n        new commands.FormatAllCommand(),\n    );\n\n    return commandManager;\n}\n\n"],"sourceRoot":""}